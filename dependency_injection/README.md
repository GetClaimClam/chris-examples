# Dependency Injection

Note: this folder will not build correctly as it is a collection of loose files as examples.

## Inversion of Control / Dependency Injection
**Inversion of Control** is a software design principle that gives control of an application's flow to an external source. 

**Dependency Injection** is a common technique to accomplish Inversion of Control. By injecting a dependency into a function at runtime, the (external) injected dependency controls the flow of the program.

**Benefits**
- Loose Coupling. Developers can write code that is easier to maintain and test.
- Reduced Complexity. Developers can keep core business logic clear and concise.

# Example

Below are some simple files that use dependency injection, Golang interfaces, generated mocks, and AI generated unit tests.

**Important**: You can read every line of the API code and storage interface, but you will have *no idea* what database we're using to store users. This database dependency is injected at runtime. During tests, we inject a mock, but in a live environment, it is ... (?)

### API - list_friends.go

Simple API to list friends of a user. Uses **dependency injection** for a "storage" interface. Doesn't care how storage is implemented, just cares about the inputs and outputs. Also uses "authenticator" interface, again not caring about the implementation of it.

### API Testing- list_friends_test.go

API tests entirely generated by ChatGPT 4o by referencing the `list_users.go` file and an example testing template. Uses generated mocks and checks all the exit points.

### Storage Interface - storage.go

A list of methods that are agnostic to implementation (can be backed by DynamoDB, Redis, PostGres, Blockchain, Crop Fields, whatever).

This should probably be multiple interfaces, but it was tolerable tech debt.

### Storage Mock - storage_mock.go

A **generated** mock based off the storage interface. Generated by `mockery` go tool.
